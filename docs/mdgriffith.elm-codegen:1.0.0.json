[
    {
        "name": "Elm",
        "comment": "\n\n@docs File, file\n\n\n## Basics\n\n@docs Expression, toString\n\n@docs bool, int, float, char, string, hex, unit\n\n@docs maybe, just, nothing\n\n@docs list, tuple, triple\n\n@docs withType\n\n\n## Records\n\n@docs record, get, updateRecord\n\n\n## Flow control\n\n@docs ifThen\n\n**Note** If you need `let` or `case` expressions, check out the docs for [`Elm.Let`](./Elm-Let) or [`Elm.Case`](./Elm-Case)!\n\n\n## Declarations\n\nA `Declaration` is anything that is at the \"top level\" of your file, meaning all values with no indentation.\n\n@docs Declaration\n\n@docs comment, declaration\n\n@docs withDocumentation\n\n@docs expose, exposeWith\n\n@docs fileWith, docs\n\n\n## Functions\n\n@docs fn, fn2, fn3, fn4, fn5, fn6, function, functionReduced\n\n\n## Custom Types\n\n@docs customType, Variant, variant, variantWith\n\n@docs alias\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Parsing existing Elm\n\n@docs parse, unsafe\n\n\n# Low-level\n\n@docs apply, value\n\n@docs unwrap, unwrapper\n\n",
        "unions": [
            {
                "name": "Variant",
                "comment": " ",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [
            {
                "name": "Declaration",
                "comment": " ",
                "args": [],
                "type": "Internal.Compiler.Declaration"
            },
            {
                "name": "Expression",
                "comment": " ",
                "args": [],
                "type": "Internal.Compiler.Expression"
            },
            {
                "name": "File",
                "comment": " ",
                "args": [],
                "type": "{ path : String.String, contents : String.String }"
            }
        ],
        "values": [
            {
                "name": "alias",
                "comment": " A custom type declaration.\n\n    import Elm.Annotation as Type\n\n    Elm.alias \"MyAlias\"\n        (Type.record\n            [ ( \"one\", Type.string )\n            , ( \"two\", Type.int )\n            , ( \"three\", Type.var \"content\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias content =\n        { one : String\n        , two : Int\n        , three : content\n        }\n\n",
                "type": "String.String -> Elm.Annotation.Annotation -> Elm.Declaration"
            },
            {
                "name": "apply",
                "comment": " ",
                "type": "Elm.Expression -> List.List Elm.Expression -> Elm.Expression"
            },
            {
                "name": "bool",
                "comment": " ",
                "type": "Basics.Bool -> Elm.Expression"
            },
            {
                "name": "char",
                "comment": " ",
                "type": "Char.Char -> Elm.Expression"
            },
            {
                "name": "comment",
                "comment": " Renders a multiline comment.\n\n    Elm.comment \"\"\"Here is my comment!\"\"\"\n\nWill generate\n\n\n\n    {- Here is my comment! -}\n\n",
                "type": "String.String -> Elm.Declaration"
            },
            {
                "name": "customType",
                "comment": " A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ Elm.variant \"One\"\n        , Elm.variantWith \"Two\"\n            [ Elm.Annotation.list Elm.Annotation.string ]\n        ]\n\nWill result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n",
                "type": "String.String -> List.List Elm.Variant -> Elm.Declaration"
            },
            {
                "name": "declaration",
                "comment": " ",
                "type": "String.String -> Elm.Expression -> Elm.Declaration"
            },
            {
                "name": "docs",
                "comment": " Render a standard docstring.\n\n    @docs one, two, three\n\nIf a `group` has been given, it will be rendered as a second level header.\n\n```markdown\n## Group name\n\n@docs one, two, three\n```\n\n",
                "type": "{ group : Maybe.Maybe String.String, members : List.List String.String } -> String.String"
            },
            {
                "name": "expose",
                "comment": " By default, everything is exposed for your module.\n\nHowever, you can tag specific declarations you want exposed, and then only those things will be exposed.\n\n",
                "type": "Elm.Declaration -> Elm.Declaration"
            },
            {
                "name": "exposeWith",
                "comment": " You can also add a group tag to an exposed value. This will automatically group the `docs` statements in the module docs.\n\nFor precise control over what is rendered for the module comment, use [fileWith](#fileWith).\n\n",
                "type": "{ exposeConstructor : Basics.Bool, group : Maybe.Maybe String.String } -> Elm.Declaration -> Elm.Declaration"
            },
            {
                "name": "file",
                "comment": " Build a file!\n\n    Elm.file [ \"My\", \"Module\" ]\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\n",
                "type": "List.List String.String -> List.List Elm.Declaration -> Elm.File"
            },
            {
                "name": "fileWith",
                "comment": " Same as [file](#file), but you have more control over how the module comment is generated!\n\nPass in a function that determines how to render a `@docs` comment.\n\nEach exposed item is grouped based on the string used in [exposeWith](#exposeWith).\n\n**aliases** allow you to specify a module alias to be used.\n\n    aliases =\n        [ ( [ \"Json\", \"Encode\" ], \"Encode\" )\n        ]\n\nwould make an import statement like\n\n    import Json.Encode as Encode\n\nAll values rendered in this file that are from this module would also automatically respect this alias as well.\n\n",
                "type": "List.List String.String -> { docs : List.List { group : Maybe.Maybe String.String, members : List.List String.String } -> List.List String.String, aliases : List.List ( List.List String.String, String.String ) } -> List.List Elm.Declaration -> Elm.File"
            },
            {
                "name": "float",
                "comment": " ",
                "type": "Basics.Float -> Elm.Expression"
            },
            {
                "name": "fn",
                "comment": " Create a function with a single argument.\n\nThis may seem a little weird the first time you encounter it, so let's break it down.\n\nHere's what's happening for the `fn*` functions —\n\n  - The `String` arguments are the **names of the arguments** for the generated function.\n  - The attached `Maybe Annotation` is the type annotation. If you provide `Nothing`, then `elm-codegen` will infer the type for you!\n  - The `(Expression -> Expression)` function is where we're providing you an `Expression` that represents an argument coming in to the generated function.\n\nSo, this\n\n    Elm.fn ( \"firstInt\", Nothing )\n        (\\firstArgument ->\n            Elm.plus\n                (Elm.int 42)\n                firstArgument\n        )\n\nGenerates\n\n    \\firstInt -> 42 + firstInt\n\nIf you want to generate a **top level** function instead of an anonymous function, use `Elm.declaration`.\n\n    Elm.declaration \"add42\" <|\n        Elm.fn ( \"firstInt\", Nothing )\n            (\\firstArgument ->\n                Elm.plus\n                    (Elm.int 42)\n                    firstArgument\n            )\n\nResults in\n\n    add42 : Int -> Int\n    add42 firstInt =\n        42 + firstInt\n\n**Note** — Elm CodeGen will protect variable names if they're used in a nested `fn*` by adding a string of numbers to the end of the name. So, you may see a variable name be something like `myVariable_0_1`.\n\nIf you absolutely don't want this behavior, you'll need to use [`functionAdvanced`](#functionAdvanced).\n\n",
                "type": "( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "fn2",
                "comment": " ",
                "type": "( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "fn3",
                "comment": " ",
                "type": "( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "fn4",
                "comment": " ",
                "type": "( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "fn5",
                "comment": " ",
                "type": "( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "fn6",
                "comment": " ",
                "type": "( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "function",
                "comment": " You may run into situations where you don't know the number of arguments for a function at compile-time.\n\nIn that case you can use `function`. It follows the same pattern as the `fn*` functions.\n\nProvide it with —\n\n  - A list of argument names and an optional type\n  - A function which will be given all the input arguments as `Expression`s.\n\n",
                "type": "List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "functionReduced",
                "comment": " This is a special case of function declaration which will _reduce_ itself if possible.\n\nMeaning, if this would generate the following code\n\n    \\myArg -> someOtherFunction myArg\n\nThen it will replace itself with just\n\n    someOtherFunction\n\n**Note** you likely won't need this! It's generally used by the package-helper generator, but that might be a relatively special case.\n\n",
                "type": "String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "get",
                "comment": "\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n",
                "type": "String.String -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "hex",
                "comment": " ",
                "type": "Basics.Int -> Elm.Expression"
            },
            {
                "name": "ifThen",
                "comment": "\n\n    ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.string \"no\")\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else\n        \"no\"\n\nIf you need more than one branch, then chain them together!\n\n     Elm.ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.ifThen (Elm.bool True)\n            (Elm.string \"maybe\")\n            (Elm.string \"no\")\n        )\n\nWill generate\n\n    if True then\n        \"yes\"\n\n    else if True then\n        \"maybe\"\n\n    else\n        \"no\"\n\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "int",
                "comment": " ",
                "type": "Basics.Int -> Elm.Expression"
            },
            {
                "name": "just",
                "comment": " ",
                "type": "Elm.Expression -> Elm.Expression"
            },
            {
                "name": "list",
                "comment": " ",
                "type": "List.List Elm.Expression -> Elm.Expression"
            },
            {
                "name": "maybe",
                "comment": " ",
                "type": "Maybe.Maybe Elm.Expression -> Elm.Expression"
            },
            {
                "name": "nothing",
                "comment": " ",
                "type": "Elm.Expression"
            },
            {
                "name": "parse",
                "comment": " ",
                "type": "String.String -> Result.Result String.String { declarations : List.List Elm.Declaration }"
            },
            {
                "name": "portIncoming",
                "comment": "\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\"\n        [ Type.string\n        , Type.int\n        ]\n\nResults in\n\n    port receiveMessageFromTheWorld :\n        (String -> Int -> msg)\n        -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using [`Elm.expose`](#expose).\n\n",
                "type": "String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"
            },
            {
                "name": "portOutgoing",
                "comment": " Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n",
                "type": "String.String -> Elm.Annotation.Annotation -> Elm.Declaration"
            },
            {
                "name": "record",
                "comment": "\n\n    Elm.record\n        [ ( \"name\", Elm.string \"Elm\" )\n        , ( \"designation\", Elm.string \"Pretty fabulous\" )\n        ]\n\n",
                "type": "List.List ( String.String, Elm.Expression ) -> Elm.Expression"
            },
            {
                "name": "string",
                "comment": " ",
                "type": "String.String -> Elm.Expression"
            },
            {
                "name": "toString",
                "comment": " See what code this expression would generate!\n\n**Note** - Check out the `Elm.ToString` module if this doesn't quite meet your needs!\n\n",
                "type": "Elm.Expression -> String.String"
            },
            {
                "name": "triple",
                "comment": " ",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "tuple",
                "comment": " ",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "unit",
                "comment": " ",
                "type": "Elm.Expression"
            },
            {
                "name": "unsafe",
                "comment": " This will insert the given string into your generated file.\n\nCheck out the [using packages/helpers guide](https://github.com/mdgriffith/elm-codegen/tree/main/guide/UsingHelpers.md). If you're reaching for this, it's likely you'd be better off using a local helper file!\n\n",
                "type": "String.String -> Elm.Declaration"
            },
            {
                "name": "unwrap",
                "comment": " Unwraps a single-variant type\n\n    Elm.declaration \"myFunction\" <|\n        Elm.fn \"val\"\n            (\\val ->\n                Elm.unwrap \"MyType\" val\n            )\n\nResults in the following lambda\n\n    myFunction val =\n        (\\(MyType val) -> val) val\n\n",
                "type": "List.List String.String -> String.String -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "unwrapper",
                "comment": " Generate a lambda which unwraps a single-variant type.\n\n    Elm.unwrapper [ \"MyModule\" ] \"MyType\"\n\nResults in the following lambda\n\n    \\(MyModule.MyType val) -> val\n\n",
                "type": "List.List String.String -> String.String -> Elm.Expression"
            },
            {
                "name": "updateRecord",
                "comment": "\n\n    myRecord\n        |> updateRecord\n            [ ( \"designation\", Elm.string \"Pretty fabulous\" )\n            ]\n\nResults in\n\n    { myRecord | designation = \"Pretty fabulous\" }\n\n",
                "type": "List.List ( String.String, Elm.Expression ) -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "value",
                "comment": " ",
                "type": "{ importFrom : List.List String.String, name : String.String, annotation : Maybe.Maybe Elm.Annotation.Annotation } -> Elm.Expression"
            },
            {
                "name": "variant",
                "comment": " ",
                "type": "String.String -> Elm.Variant"
            },
            {
                "name": "variantWith",
                "comment": " ",
                "type": "String.String -> List.List Elm.Annotation.Annotation -> Elm.Variant"
            },
            {
                "name": "withDocumentation",
                "comment": " Add a documentation comment to a declaration!\n",
                "type": "String.String -> Elm.Declaration -> Elm.Declaration"
            },
            {
                "name": "withType",
                "comment": " Sometimes you may need to add a manual type annotation.\n\n    import Elm.Annotation as Type\n\n    Elm.value \"myString\"\n        |> Elm.withType Type.string\n\nThough be sure `elm-codegen` isn't already doing this automatically for you!\n\n",
                "type": "Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Annotation",
        "comment": "\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs named, namedWith\n\n@docs maybe, list, tuple, triple, set, dict, result\n\n@docs record, extensible, alias\n\n@docs function\n\n@docs toString\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Annotation",
                "comment": " ",
                "args": [],
                "type": "Internal.Compiler.Annotation"
            }
        ],
        "values": [
            {
                "name": "alias",
                "comment": " The classic example of a Model\n\n    Elm.Annotation.alias []\n        \"Model\"\n        []\n        (Elm.Annotation.record\n            [ ( \"hello\", Elm.Annotation.string ) ]\n        )\n\nwould correspond to\n\n    type alias Model =\n        { hello : String\n        }\n\n",
                "type": "List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "bool",
                "comment": " ",
                "type": "Elm.Annotation.Annotation"
            },
            {
                "name": "char",
                "comment": " ",
                "type": "Elm.Annotation.Annotation"
            },
            {
                "name": "dict",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "extensible",
                "comment": " ",
                "type": "String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"
            },
            {
                "name": "float",
                "comment": " ",
                "type": "Elm.Annotation.Annotation"
            },
            {
                "name": "function",
                "comment": " ",
                "type": "List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "int",
                "comment": " ",
                "type": "Elm.Annotation.Annotation"
            },
            {
                "name": "list",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "maybe",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "named",
                "comment": " ",
                "type": "List.List String.String -> String.String -> Elm.Annotation.Annotation"
            },
            {
                "name": "namedWith",
                "comment": " ",
                "type": "List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "record",
                "comment": " ",
                "type": "List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"
            },
            {
                "name": "result",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "set",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "string",
                "comment": " ",
                "type": "Elm.Annotation.Annotation"
            },
            {
                "name": "toString",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> String.String"
            },
            {
                "name": "triple",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "tuple",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"
            },
            {
                "name": "unit",
                "comment": " ",
                "type": "Elm.Annotation.Annotation"
            },
            {
                "name": "var",
                "comment": " A type variable\n",
                "type": "String.String -> Elm.Annotation.Annotation"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Case",
        "comment": " Generate a case expression!\n\nHere's an example for extracting a `Maybe Int`\n\n    Elm.Case.maybe myMaybe\n        { nothing = Elm.int 0\n        , just =\n            ( \"value\"\n            , \\content ->\n                Elm.plus (Elm.int 5) content\n            )\n        }\n\nGenerates\n\n    case myMaybe of\n        Nothing ->\n            0\n\n        Just value ->\n            value + 5\n\n@docs maybe, result, list, string\n\n@docs tuple, triple\n\n\n## Case on a Custom Type\n\n    Elm.Case.custom maybeString\n        [ Elm.Case.branch0 \"Nothing\"\n            (Elm.string \"It's nothing, I swear!\")\n        , Elm.Case.branch1 \"Just\" ( \"val\", Elm.Annotation.string ) <|\n            \\val ->\n                Elm.append (Elm.string \"Actually, it's: \") val\n        ]\n\nGenerates\n\n    case maybeString of\n        Nothing ->\n            \"It's nothing, I swear!\"\n\n        Just just ->\n            \"Actually, it's: \" ++ just\n\n@docs custom\n\n@docs Branch, otherwise, branch0, branch1, branch2, branch3, branch4, branch5, branch6\n\n@docs branchWith\n\n@docs branchList\n\n",
        "unions": [
            {
                "name": "Branch",
                "comment": " ",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "branch0",
                "comment": " ",
                "type": "String.String -> Elm.Expression -> Elm.Case.Branch"
            },
            {
                "name": "branch1",
                "comment": " ",
                "type": "String.String -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branch2",
                "comment": " ",
                "type": "String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branch3",
                "comment": " ",
                "type": "String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branch4",
                "comment": " ",
                "type": "String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branch5",
                "comment": " ",
                "type": "String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branch6",
                "comment": " ",
                "type": "String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branchList",
                "comment": " ",
                "type": "Basics.Int -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "branchWith",
                "comment": " ",
                "type": "String.String -> Basics.Int -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "custom",
                "comment": " ",
                "type": "Elm.Expression -> Elm.Annotation.Annotation -> List.List Elm.Case.Branch -> Elm.Expression"
            },
            {
                "name": "list",
                "comment": " Let's unpack the first value from a list.\n\n    Elm.Case.list myList\n        { empty = Elm.int 0\n        , nonEmpty =\n            \\top remaining ->\n                Elm.plus (Elm.int 5) top\n        }\n\nGenerates\n\n    case myList of\n        [] ->\n            0\n\n        top :: remaining ->\n            top + 5\n\n**Note** if you want more control over unpacking lists, check out [`branchList`](#branchList)\n\n",
                "type": "Elm.Expression -> { empty : Elm.Expression, nonEmpty : Elm.Expression -> Elm.Expression -> Elm.Expression } -> Elm.Expression"
            },
            {
                "name": "maybe",
                "comment": " ",
                "type": "Elm.Expression -> { nothing : Elm.Expression, just : ( String.String, Elm.Expression -> Elm.Expression ) } -> Elm.Expression"
            },
            {
                "name": "otherwise",
                "comment": " A catchall branch in case you want the case to be nonexhaustive.\n",
                "type": "(Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"
            },
            {
                "name": "result",
                "comment": "\n\n    Elm.Case.result myResult\n        { ok =\n            Tuple.pair \"ok\" <|\n                \\ok ->\n                    Elm.string \"No errors\"\n        , err =\n            Tuple.pair \"err\" <|\n                \\err ->\n                    err\n        }\n\nGenerates\n\n    case myResult of\n        Ok ok ->\n            \"No errors\"\n\n        Err err ->\n            err\n\n",
                "type": "Elm.Expression -> { err : ( String.String, Elm.Expression -> Elm.Expression ), ok : ( String.String, Elm.Expression -> Elm.Expression ) } -> Elm.Expression"
            },
            {
                "name": "string",
                "comment": " ",
                "type": "Elm.Expression -> { cases : List.List ( String.String, Elm.Expression ), otherwise : Elm.Expression } -> Elm.Expression"
            },
            {
                "name": "triple",
                "comment": "\n\n    Elm.Case.triple myTriple\n        \"one\"\n        \"two\"\n        \"three\"\n        (\\one two three ->\n            Elm.plus (Elm.int 5) two\n        )\n\nGenerates\n\n    case myTriple of\n        ( one, two, three ) ->\n            5 + two\n\n",
                "type": "Elm.Expression -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            },
            {
                "name": "tuple",
                "comment": "\n\n    Elm.Case.tuple myTuple\n        \"first\"\n        \"second\"\n        (\\one two ->\n            Elm.plus (Elm.int 5) two\n        )\n\nGenerates\n\n    case myTuple of\n        ( first, second ) ->\n            5 + second\n\n",
                "type": "Elm.Expression -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Let",
        "comment": " This module is for building `let` expressions.\n\n@docs letIn, value\n\nHere's a brief example to get you started\n\n    Elm.Let.letIn\n        (\\one two ->\n            Elm.Op.append one two\n        )\n        |> Elm.Let.value \"one\" (Elm.string \"Hello\")\n        |> Elm.Let.value \"two\" (Elm.string \"World!\")\n        |> Elm.Let.toExpression\n\nWill translate into\n\n    let\n        one =\n            \"Hello!\"\n\n        two =\n            \"World\"\n    in\n    one ++ two\n\n\n# Destructing values\n\n@docs tuple\n\nHere's an example destructing a tuple. This code\n\n    Elm.Let.letIn\n        (\\( first, second ) ->\n            Elm.Op.append first second\n        )\n        |> Elm.Let.tuple \"first\" \"second\" (Elm.tuple (Elm.string \"Hello\") (Elm.string \"World!\"))\n        |> Elm.Let.toExpression\n\nWill generate\n\n    let\n        ( first, second ) =\n            ( \"Hello\", \"World!\" )\n    in\n    first ++ second\n\n@docs record\n\nAnd extracting fields from a record.\n\n    Elm.Let.letIn\n        (\\fields ->\n            case fields of\n                [ first, second ] ->\n                    Elm.Op.append first second\n\n                _ ->\n                    Elm.unit\n        )\n        |> Elm.Let.record [ \"first\", \"second\" ]\n            (Elm.record\n                [ ( \"first\", Elm.string \"Hello\" )\n                , ( \"second\", Elm.string \"world!\" )\n                ]\n            )\n        |> Elm.Let.toExpression\n\nWill generate:\n\n    let\n        { first, second } =\n            { first = \"Hello\", second = \"world!\" }\n    in\n    first ++ second\n\n\n# Functions\n\nHere's an example of declaring functions in a let expression:\n\n    Elm.Let.letIn\n        (\\myFn ->\n            myFn (Elm.bool True)\n        )\n        |> Elm.Let.fn \"myFn\"\n            ( \"arg\", Just Type.bool )\n            (\\arg ->\n                Elm.ifThen arg\n                    (Elm.string \"True\")\n                    (Elm.string \"False\")\n            )\n        |> Elm.Let.toExpression\n\nwill generate\n\n    let\n        myFn arg =\n            if arg then\n                \"True\"\n\n            else\n                \"False\"\n    in\n    myFn True\n\n@docs fn, fn2, fn3\n\n@docs toExpression\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "fn",
                "comment": " ",
                "type": "String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"
            },
            {
                "name": "fn2",
                "comment": " ",
                "type": "String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"
            },
            {
                "name": "fn3",
                "comment": " ",
                "type": "String.String -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Let.Let ((Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> a) -> Elm.Let.Let a"
            },
            {
                "name": "letIn",
                "comment": " ",
                "type": "a -> Elm.Let.Let a"
            },
            {
                "name": "record",
                "comment": " ",
                "type": "List.List String.String -> Elm.Expression -> Elm.Let.Let (List.List Elm.Expression -> a) -> Elm.Let.Let a"
            },
            {
                "name": "toExpression",
                "comment": " ",
                "type": "Elm.Let.Let Elm.Expression -> Elm.Expression"
            },
            {
                "name": "tuple",
                "comment": " ",
                "type": "String.String -> String.String -> Elm.Expression -> Elm.Let.Let (( Elm.Expression, Elm.Expression ) -> a) -> Elm.Let.Let a"
            },
            {
                "name": "value",
                "comment": " ",
                "type": "String.String -> Elm.Expression -> Elm.Let.Let (Elm.Expression -> a) -> Elm.Let.Let a"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.Op",
        "comment": " This module helps generate operators!\n\nSo, this\n\n    Elm.Op.equal (Elm.bool True) (Elm.bool False)\n\nWould generate\n\n    True == False\n\n\n## Equality\n\n@docs equal, notEqual, and, or\n\n\n## Lists and strings\n\n@docs append, cons\n\n\n## Math\n\n@docs plus, minus, multiply, divide, intDivide, power\n\n\n## Comparisons\n\n@docs lt, gt, lte, gte\n\n@docs pipe\n\n@docs parens\n\n\n## Parsing\n\n@docs keep, skip\n\n\n## Url parsing\n\n@docs slash, query\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "and",
                "comment": " `&&`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "append",
                "comment": " `++`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "cons",
                "comment": " `::`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "divide",
                "comment": " `/`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "equal",
                "comment": " `==`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "gt",
                "comment": " `>`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "gte",
                "comment": " `>=`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "intDivide",
                "comment": " `//`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "keep",
                "comment": " used in the `elm/parser` library\n\n`|=`\n\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "lt",
                "comment": " `<`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "lte",
                "comment": " `<=`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "minus",
                "comment": " `-`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "multiply",
                "comment": " `*`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "notEqual",
                "comment": " `/=`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "or",
                "comment": " `||`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "parens",
                "comment": " Wrap an expression in parentheses.\n\nGenerally you won't need this as `elm-codegen` handles parens for you, but it can be useful to semantically group operations from this module.\n\n",
                "type": "Elm.Expression -> Elm.Expression"
            },
            {
                "name": "pipe",
                "comment": " `|>`\n\n    Elm.value \"thang\"\n        |> Elm.pipe (Elm.value \"thang2\")\n        |> Elm.pipe (Elm.value \"thang3\")\n\nResults in\n\n    thang\n        |> thang2\n        |> thang3\n\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "plus",
                "comment": " `+`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "power",
                "comment": " The to-the-power-of operator `^`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "query",
                "comment": " `<?>` used in url parsing\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "skip",
                "comment": " `|.`\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            },
            {
                "name": "slash",
                "comment": " `</>` used in url parsing\n",
                "type": "Elm.Expression -> Elm.Expression -> Elm.Expression"
            }
        ],
        "binops": []
    },
    {
        "name": "Elm.ToString",
        "comment": " Convert values to a string!\n\nThis can be useful if you're generating examples or just playing with the library and want to get an intuition for it.\n\n@docs expression, annotation, declaration\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "annotation",
                "comment": " ",
                "type": "Elm.Annotation.Annotation -> { imports : String.String, signature : String.String }"
            },
            {
                "name": "declaration",
                "comment": " ",
                "type": "Elm.Declaration -> { imports : String.String, docs : String.String, signature : String.String, body : String.String }"
            },
            {
                "name": "expression",
                "comment": " ",
                "type": "Elm.Expression -> { imports : String.String, body : String.String, signature : String.String }"
            }
        ],
        "binops": []
    }
]